var numTrees = function(nums){
  var dp = new Array(nums+1).fill(0)
  dp[0] = 1,dp[1]=1
  for(var i = 2; i < nums;i++){ // n个节点有多少种二叉树, 由于 dp[n]个节点需要由 dp[n-1],dp[n-2],dp[n-3],...dp[1] 
                                // 去得出答案,所以看起来
    for(var j = 1;j<=i;j++){    // 
      dp[i] += dp[j-1]*dp[i-j]  // 通过第二层遍历去得到第n个数时会有多少种情况
    }
  }
  return dp[n]
}
// 递推函数如下: G(n) = G(0)*G(n-1)+G(1)*(n-2)+...+G(n-1)*G(0)

// 下面记录一下运算的过程
// dp[2] = dp[0]*dp[1] + dp[1]*dp[0] = 1 * 1 + 1* 1 = 2  => 从 d[0] = 1,d[1] 得到 d[2] = 2
// dp[3] = dp[0]*dp[1] + dp[1]*dp[2] + dp[2]*dp[0] = 1*1 + 1*2 + 2*1 = 5 => 从d[2] 得到 d[3] = 5
// ...
// dp[n] = dp[0]*dp[n-1] + dp[1]*dp[n-2] + ... dp[n-1]*dp[0]   => dp[n]的值由前面 d[0],d[1],d[2],...,d[n-1]得出

// 感觉dp应该是一种计算机的思维,是一种 自底向上的过程。这样说起来可能有点难想,
// 所以这就导致有人更喜欢用 递归+ 记忆的方式,也就是自顶向下的方式可会更好理解。

// 关于自底向上和递归+记忆化 ：https://blog.csdn.net/u013309870/article/details/75193592 
// 这篇文章写的很好
