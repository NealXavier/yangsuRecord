/**
 * 题意解析: https://www.bilibili.com/video/av64978995?from=search&seid=3200937483760830982   
 */
/**
 *  本题解析: 
 *  [h,k]
 *   输入: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]] 
 *   输出: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
 *  讲真，刚开始没看清楚题意到底是想讲什么，后来弄懂了这个输出的意思：
 *  [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
 *  在(5) 前面>=5的元素有0个, 
 *  在(7) 前面>=7的元素有0个
 *  在(5) 前面>=5的元素有2个
 *  ....,以此类推
 *  
 *  首先需要将数组按照 身高(h)进行排序, 这时候问题来了，到底是从小到大排,还是从大到小去排
 *  答案是从大到小, 为什么呢？
 *   如果是从小到大的话:
 *    [[4,4],[[5,0],[5,2],[6,1],[7,0],[7,1]]
 *   这时候 [4,4] 是需要前面有4个>=4的元素的,而 数组 splice方法 是没有办法直接把一个元素定死在index = 4上的,
 *   它会被后面的元素 "推"到前面来
 *   而反观如果从大到小
 *    [[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]]
 *   
 *   你会觉得和最终结果之间相差毫厘,
 *    而且在这时会发现,[h,k] 后面的 k就是元素插入的最终位置,世界真奇妙
 *    [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
 *   成功完成.
 *   ** 这当中还会有一个细节值得注意: 就是排序时当两个元素相同时,到底k是从小到大还是从大到小这值得玩味
 *   来复盘一下:从大到小的情况
 *   [[7,1],[7,0],[6,1],[5,2],[5,0],[4,4]]
 *   如果按照这种顺序选择插入的结果就会是:
 *   [[5,0],[7,0],[6,1],[5,2],[4,4],[7,1]]
 *   显然[5,2]的位置是错的,[5,2]前面有3个元素>=5 
 *   回想为什么会这样 ?
 *   具有相同h的元素, k更小的那一个更应该早点确定位置, 这更像是一种经验。
 */
var reconstructQueue = function(people){
  var res = []
  people.sort((a,b)=> (a[0] === b[0])?a[1]-b[1] : b[0] - a[0])
  people.map((item,index)=>res.splice(item[1],0,item))
  return res
}
