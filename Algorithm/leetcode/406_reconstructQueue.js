/**
 * 题意解析: https://www.bilibili.com/video/av64978995?from=search&seid=3200937483760830982   
 */
/**
 *  本题解析: 
 *  [h,k]
 *   输入: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]] 
 *   输出: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
 *  讲真，刚开始没看清楚题意到底是想讲什么，后来弄懂了这个输出的意思：
 *  [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
 *  在(5) 前面>=5的元素有0个, 
 *  在(7) 前面>=7的元素有0个
 *  在(5) 前面>=5的元素有2个
 *  ....,以此类推
 *  
 *  首先需要将数组按照 身高(h)进行排序, 这时候问题来了，到底是从小到大排,还是从大到小去排
 *  答案是从大到小, 为什么呢？
 *   如果是从小到大的话:
 *    [[4,4],[[5,0],[5,2],[6,1],[7,0],[7,1]]
 *   这时候 [4,4] 是需要前面有4个>=4的元素的,而 数组 splice方法 是没有办法直接把一个元素定死在index = 4上的,
 *   它会被后面的元素 "推"到前面来
 *   而反观如果从大到小
 *    [[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]]
 *   
 *   你会觉得和最终结果之间相差毫厘,
 *    而且在这时会发现,[h,k] 后面的 k就是元素插入的最终位置,世界真奇妙
 *    [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
 *   成功完成.
 *   ** 这当中还会有一个细节值得注意: 就是排序时当两个元素相同时,到底k是从小到大还是从大到小这值得玩味
 *   来复盘一下:从大到小的情况
 *   [[7,1],[7,0],[6,1],[5,2],[5,0],[4,4]]
 *   如果按照这种顺序选择插入的结果就会是:
 *   [[5,0],[7,0],[6,1],[5,2],[4,4],[7,1]]
 *   显然[5,2]的位置是错的,[5,2]前面有3个元素>=5 
 *   回想为什么会这样 ?
 *   具有相同h的元素, k更小的那一个更应该早点确定位置, 这更像是一种经验。
 */
var reconstructQueue = function(people){
  var res = []
  people.sort((a,b)=> (a[0] === b[0])?a[1]-b[1] : b[0] - a[0])
  people.map((item,index)=>res.splice(item[1],0,item))
  return res
}

/**
 * leetcode 题解的其他解释:
 * 
 * 身高从高到低排序的好处是，对于前面已经排好的队，
 * 1.如果下一个人(h,k)比前面所有人都矮，那么，他插入队列的k处，使其达到k的要求，对其他人没影响，达到要求！ 
 * 2.如果下一个人跟之前排好队的人中最矮的身高一样，这时候，就体现为什么之前排序时候，先考虑身高，再按照k的升序了，
 *   这时候，新来的人虽然与之前最矮之人身高一样，但是由于他的k比之前最矮的人的k都大，所以，他插入的地方一定在已经排好队的，
 *   和他身高一样的，最矮之人的后面，对这些最矮人们没有影响，当然，对其他比他高的人就更没有影响了。
    其只要了解一点：我们一个一个地排队，对于前面已经排好的队，如果我们在k的位置插入一个新人，
    那么对k之前的人没有任何影响，对于k之后比新人高的人也没有任何影响，因此，我们每插入一个人的时候，
    要么保证前面所有人都比新人高，要么至少保证插入的位置后面的所有人都比新人高
 */
