Q1：什么是主机名

eg. http://blog.sina.com.cn/中，

blog是提供博客服务的那台机器的名字，sina.com.cn是域名，blog.sina.com.cn是主机名。



Q2:http1.0和http1.1的区别：

```
- 缓存处理：
   http1.0中主要使用header里面的If-Modified-Since,Expires 来做为缓存判断标准，
   HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since,If-Match,If-None-Match等更多可供选择缓存的头来控制缓存策略。
   
- 带宽优化及网络连接的使用，
  http1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。
  http1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码为206（Partial Content）,这样就方便了开发者自由选择以便于充分利用宽度和连接。

- Host头处理，
  http1.0中认为每台服务器都绑定一个唯一的ip地址，因此，请求消息中的url并没有传递主机名（主机名定义见Q1）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在虚拟主机（Muti-homed Web Servers），并且它们会共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）
  
- 长连接
  http1.1支持长连接和请求的流水线（Pipeling）处，在一个tcp连接上可以传送多个http请求和相应，减少了建立和关闭连接的消耗和延迟，在http1.1中默认开启connection: keep-alive,一定程度上弥补了http1.0每次请求都要创建连接的缺点。
```

Q3：https和http的一些区别

```
- https协议需要到CA(Certificate Authority"证书颁发机构")申请证书，一般免费证书很少，需要交费。

- http协议运行在tcp之上，所有传输的内容都是明文。https运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。

- http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，
后者是443.

- https可以有效的防止运营商劫持，解决了防劫持的一个大问题。
```

Q4：http2.0和http1.0相比的新特性

```
- 新的二进制格式（Binary Format）
 http1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做懂啊健壮性考虑的场景必然很多，二进制不同，只认0和1的组合。基于这种考虑http2.0的协议解析决定采用二进制格式，实现方便且健壮。
 
 - 多路复用（MultiPlexing）
 即连接共享，即每一个request都是用做连接共享机制。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的id将 request再归属到各自不同的服务器端请求里面。通过单一的http2.0连接发起多重的请求-响应消息，即在一个连接里，客户端和浏览器都可以同时发送多个请求和相应，而不用按照顺序一一对应，这样避免了“队头堵塞”。http2.0把http协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。并行地在同一个tcp连接上双向交换消息。
 
 - 首部压缩
 http协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。http/2对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息压缩后再发送（SPDY使用的是通用的DEFLATE算法，而HTTP/2则使用了专门为首部压缩而设计的HPACK算法）。另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段，发送索引号，这样就提高速度了。
 
 - 服务端推送：
 http2.0允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析html源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端。
```

Q5：关于http2.0的多路复用是怎么回事

```
在http1.0的时代，每次请求都会建立一次http连接。也就是我们常说的3次握手4次挥手，这个过程在一次请求过程中占用了相当长的时间，而且逻辑上是非必需的，因为不间断的请求数据，第一次连接是正常的，以后就占用这个通道，下载其他文件，这时就引入了 Keep-Alive。

Keep-Alive解决的核心问题是在一定时间内，同一域名多次请求数据，只建立一次http请求，其他请求可以复用每一次建立的连接通达。并且这里的一定时间是可以配置的。

但是Keep-Alive依然存在两个效率上的问题。

- 串行的文件传输。当请求a文件时，b文件只能等待，等待a连接到服务其，服务器处理文件，服务器返回文件，这三个步骤。假如都是用时1s，

- 连接数过多。假设Apache设置了最大并发数为300，因此浏览器限制，浏览器发起的最大请求数为6，也就是服务器能承载的最高并发为50，当51个人访问时，就需要等待前面某个请求处理完成。


这时候多路复用就是解决上述两个问题
解决第一个：
在http1.1的协议中，我们传输的request和response都是基于文本你的，这样就会引发：所有的数据必须按顺序传输，比如需要传输：hello world，（见图1），就只能h到d一个个传输，不能并行传输，因为接收端宾不知道这些字符的顺序，所以并行传输在http1.1是不能实现的。

HTTP/2引入二进制数据帧和流的概念，其中帧对数据进行顺序标识，如下图所示，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据，这就是流所做的事情。（见图2）

解决第二个问题：HTTP/2对同一域名下所有请求都是基于流，也就是说同一域名不管访问多少文件，也只建立一路连接。同样Apache的最大连接数为300，因为有了这个新特性，最大的并发就可以提升到300，比原来提升了6倍！
```

![图1](E:\yangsuRecord\NetWork\http\http1.png)

![图2](E:\yangsuRecord\NetWork\http\http2.png)



对头阻塞：

> 请求A 和 请求B。A 先被发起，此时 server 端接收到了 A 请求，正在处理。同时 B 请求也发过来了。但是 A 请求还没被返回，此时 B 请求只能等待。

就是通过二进制的流的形式，可以做到乱序传输，从而解决了对头阻塞的问题。